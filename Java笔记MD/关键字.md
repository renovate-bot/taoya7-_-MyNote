# this关键字

> 当成员变量与局部变量名字相同时，局部变量就会隐藏，这时就需要成员变量则使用this关键字

this关键字：当前正在使用对象的地址

- 当方法参数名和成员变量名相同时

- 在构造方法中调用当前类中的其他构造方法。**this(); 代表构造器名 必须写第一行**

- 可以当作返回值返回

- static不能和this一起使用

- 可以把this当作参数传递

# super关键字

super代表父类的实例，super可以调用父类的属性、方法、构造方法


# Static修饰符

static修饰成员时，可以理解这些成员与类相关，没有static修饰可以理解成这些成员与对象相关

static修饰通过“**类名.成员**”调用，没有static修饰通过“**对象.成员**”调用

**注意**

1. static关键字不能用于修饰构造方法
2. 在方法中不可以定义static变量

**特点**
1. static修饰的内容，是随着类的加载而加载的

2. static修饰的内容，优先于对象的存在。

3. static修饰的内容，被该类型的所有对象所共享

4. 通过 类名.成员 调用

**1. static修饰方法**
```
public static void main(String[] args) {

}
```
static修饰方法,不能调用没有static修饰的方法和属性，也不能使用this和super关键字

main()是应用程序的主入口方法，加入static表示该方法与类相关的，之所以这样定义因为是解析器

调用该方法时，没有来得及创建当前类对象。不能定义成与对象相关。

> 静态方法与非静态方法的区别  
> 1. 静态方法可以使用 类名.方法名 的方式 也可以使用 对象名.方法名。而实例方法只有后者。也就是说调用静态方法可以无需创建对象
> 2. 静态方法访问本类的成员时，只允许访问静态成员

**2.static修饰属性**
```
class Animal {
  static int count = 0;
}
```
static修饰属性时，表示该属性被多个当前类对象共享，一个对象修改静态属性后，会影响其他对象。

**3.static修饰自由代码块**

自由块{}包起来代码段,自由块中的代码在构造方法之前执行，因此可以将一部分初始化代码放在自由块中

当static修饰自由快，与类相关，只要类被加载，即使没有创建对象，也将执行。

所以，静态代码块无论创建几个对象，仅执行一次
>- 静态代码块只能定义在类里面，不能定义在方法里面
>- 静态代码块里面的变量都是静态变量，只在本块内有效
>- 随着类的加载而加载
>- 静态代码块只能访问类的静态成员，而不允许访问非静态成员

```
public class Demo_3_修饰自由块 {
	public static void main(String[] args) {
		Demo d = new Demo();	// 创建对象
		Demo.show();
	}
}
class Demo {
	private static int i=0;
	static {
		System.out.println("静态代码块执行");
		i++;
	}
	Demo() {
		System.out.println("构造方法执行");
	}
	public static void show() {
		System.out.println("i_______"+i);
	}

}
>>静态代码块执行
>>构造方法执行
>>i_______1

```



# final修饰符

final可以在类、成员变量、方法前面修饰

**1.final修饰类**

final修饰类，表示不能被其他类继承，如String和Math. 可以认为此类很完美不需要修改或扩展.
```
public final class Person {

}
```
**2.final修饰方法**

final修饰方法，表示该方法不可以在子类中重写(覆盖)。
- 不允许扩展
- 不允许任何从此类继承来覆盖这个方法。可以直接使用，但不能做修改

**3.final修饰成员变量**

final修饰成员变量，表示该变量是一个常量。
- final修饰基本数据类型的变量，一旦初始化 不可以修改
- final修饰引用数据类型的变量，引用不可以再变。
