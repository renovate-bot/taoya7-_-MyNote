<style type="text/css">
    h1 {

        font-weight: 400;
    }
    img {
        border-radius: 10px;
        box-shadow: 0 2px 8px rgba(0,0,0,.3);
    }
    body {
        background-color: #FDF6E3;
/*      margin:0;
        outline:none;
        border:none;
        max-width: 100%;*/

    }
    import::before{
        display: inline-block;
        content: "";
        width: 10px;
        height: 10px;
        background-color: red;
        margin-right: 10px;
        border-radius: 50%;
    }
    import {
        font-size:14px;
        font-weight: bold;
        padding:0.55rem;
        border-radius:5px; 
        color:#eb5055;
    }
    .markdown-body blockquote{
        border-left: 4px solid tomato;
    }
</style>

# <center>多线程</center>

<import>什么是线程</import>

1. 线程是程序执行的一条路径，一个进程中可以包含多条线程

2. 多线程并发执行可以提高程序的效率，可以同时完成多项工作 

<import>并行与并发</import>

1. 并行就是两个任务同时进行（需要多核CPU）

2. 并发就是两个任务同时请求运行，而处理器只可以接受一个任务

> ### 创建线程的三种途径

- 继承Thread类

- 实现Runnable接口（Callable接口）

**方式一**


- 继承Thread类
- 重写run方法
- 将要执行的代码写在run方法中
- 创建Thread类的子类对象
- 开启线程Start();


```java
public class _01创建线程 {
    public static void main(String[] args){
        Test1 t = new Test1();
        t.start();
        /*Main方法的运行*/
        for(int i=0; i<50; i++) {
            System.out.println("Main\t"+i);
        }
    }
}

class Test1 extends Thread{
    public Test1(){
        super();
    }
    @Override
    public void run(){ //1.覆写Run方法
        for(int i=0; i<50; i++){
            System.out.println("Test1\t"+i);
        }
    }
}
```

**方式二**

```java
public class _02创建线程 {
    public static void main(String[] args){
        Test2 t = new Test2();
        new Thread(t).start();

        for(int i=0; i<50; i++) {
            System.out.println("Main\t"+i);
        }

    }
}

class Test2 implements Runnable{
    public void run() {
        for(int i=0; i<50; i++) {
            System.out.println("Test\t"+i);
        }
    }
}
```


**方式三**

```java
import java.util.concurrent.FutureTask;
import java.util.concurrent.*;
public class _03创建线程 {
    public static void main(String[] agrs)throws Exception{
        Test3 t = new Test3();
        /*FutureTask是Runnable接口的子类，所以可以使用Thread类的构造来接受task对象*/
        FutureTask<String> a = new FutureTask<String>(t);
        FutureTask<String> b = new FutureTask<String>(t);
        FutureTask<String> c = new FutureTask<String>(t);
        new Thread(a).start();//启动多线程;
        new Thread(b).start();//启动多线程;
        new Thread(c).start();//启动多线程;

        System.out.println("A线程的返回结果\t"+a.get());
        System.out.println("B线程的返回结果\t"+b.get());
        System.out.println("C线程的返回结果\t"+c.get());
    }
}

/*多线程操作类*/
class Test3 implements Callable<String>{
    private int ticket = 10;
    @Override
    public String call() throws Exception {
        for(int i=0; i<100; i++)
        {
            if(this.ticket>0){
                System.out.println("卖票了 ticket="+this.ticket--);
            }
        }
        return "票已卖光了";
    }
}
```

> ### 多线程两种实现方式的区别

数据共享

多个线程对象访问同一个的对象用Runnable

**区别：**

- Thread类是Runnable接口的子类，使用Runnable接口实现多线程可以避免单继承局限

- Runnable接口实现的多线程可以比Thread类实现的多线程的更加清楚的描述数据共享






### 线程的优先级

- 设置优先级 public final void setPriority(int new Priority)

- 取得优先级 public final int getPriority()


- 最高优先级 public static final int MAX_PRIORITY;  10 

- 中等优先级 public static final int NORM_PRIORITY;	5
	
- 最低优先级 public static final int MIN_PRIORITY;	1



### 总结

1. Thread.currentThread()可以获取当前线程类的对象

2. Thread.sleep()主要是休眠

3. 优先级越高的线程对象越有可能先执行 


### 同步与异步


在Java里面如果想要实现线程的同步可以使用synchronized关键字

- 同步代码块

- 同步方法

同步代码块

```java
(synchronized(this){
	代码块
}
```

同步方法

```java
public synchronized void method_name() {
	代码块
}
```

同步操作与异步操作相比，异步操作的执行速度要高于同步操作。但是同步操作是安全线程操作


### 死锁

线程同步过多就可能造成死锁



<import>多个线程访问同一资源时需要考虑到哪些情况？有可能带来哪些问题？</import>

多个线程访问同一资源时一定要处理好同步，可以使用同步代码块或同步方法来解决

但是过多的使用同步有可能造成死锁



### 生产者与消费者

- 等待 public final void wait() throws InterruptedException

- 唤醒第一个等待线程 public final void notify()

- 唤醒全部等待线程，那个优先级高就先执行 public final void notifyAll()



<import>请解释sleep()与wait()方法的区别</import>

sleep()是Thread类定义的方法 wait()是Object类定义的方法

sleep()可以设置休眠时间，时间一到自动唤醒

wait()需要等待notify()进行唤醒;