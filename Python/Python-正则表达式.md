# Python-正则表达式


### 匹配规则

|    模式         |	           描述|
| ------------ | ------------ |
|a\|b|匹配a或b|
|^	 |匹配字符串的开头|
$	|匹配字符串的末尾
.	|匹配任意字符，除了换行符
[...]	|用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k'
[^...]	|不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。
*	|匹配*号前 0个或多个的表达式
+	|匹配+号前 1个或多个的表达式
re?	|匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式
re{ n}|	 
re{ n,}	|精确匹配n个前面表达式。
re{ n, m}|	匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式
a| b	|匹配a或b
(  )	|匹配括号内的表达式，也表示一个组
(?imx)|	正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。
(?-imx)	|正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。
(?: re)	|类似 (...), 但是不表示一个组
(?imx: re)|	在括号中使用i, m, 或 x 可选标志
(?-imx: re)	|在括号中不使用i, m, 或 x 可选标志
(?#...)	|注释.
(?= re)	|前向肯定界定符。如果所含正则表达式，以 ... 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。
(?! re)	|前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功
(?> re)	|匹配的独立模式，省去回溯。
\w	|匹配[A-Za-z0-9]
\W	|匹配非[A-Za-z0-9]
\s	|匹配任意空白字符，等价于 [\t\n\r\f].
\S	|匹配任意非空字符
\d	|匹配任意数字，等价于 [0-9]
\D	|匹配任意非数字
\A	|匹配字符串开始
\Z	|匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。c
\z	|匹配字符串结束
\G	|匹配最后匹配完成的位置。
\b	|匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。
\B	|匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。
\n, \t, 等.	|匹配一个换行符。匹配一个制表符。等
\1...\9	             |匹配第n个分组的子表达式。
\10	|匹配第n个分组的子表达式，如果它经匹配。否则指的是八进制字符码的表达式
|___________________________||


### RE的匹配语法

- **re.match** 从头开始匹配

- **re.search** 匹配包含

- **re.findall** 把所有匹配到的字符放到列表中的元素返回

- **re.splitall** 以匹配到的字符当作列表分隔符

- **re.sub** 匹配字符并替换

- **re.fullmatch** 全部匹配

> group()方法可以取到对象内容


### Demo

```
[0-9]{2}  匹配0~9的数字两个

res = re.search('1*','111123')
print(res.group())
> 1111

res = re.search('12+','111123')
print(res.group())
> 12

res = re.search('1{3}','111123')
print(res.group())
> 111

#分组
res = re.search('(111)(23)','1111111123').groups()
print(res)
> ('111', '23')



```


### 日常匹配模式

- URL匹配
```
pattern = re.compile(r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+')
```